<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络编程 on 刘玮的博客</title><link>https://erberry.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><description>Recent content in 网络编程 on 刘玮的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 12 Feb 2022 20:03:05 +0800</lastBuildDate><atom:link href="https://erberry.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>go源码解析之TCP连接（七）——IO多路复用之事件通知</title><link>https://erberry.github.io/post/go-tcp7/</link><pubDate>Sat, 12 Feb 2022 20:03:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp7/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 TCP连接中的IO多路复用 上一章已经介绍了将socket注册到epoll中的过程，本章将</description></item><item><title>go源码解析之TCP连接（六）——IO多路复用之事件注册</title><link>https://erberry.github.io/post/go-tcp6/</link><pubDate>Sat, 12 Feb 2022 20:02:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp6/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 TCP连接中的IO多路复用 本章将介绍golang在tcp连接中的IO多路复用的实现 1. 背景</description></item><item><title>go源码解析之TCP连接（五）——Close</title><link>https://erberry.github.io/post/go-tcp5/</link><pubDate>Sat, 12 Feb 2022 20:01:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp5/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 连接关闭 上一章我们通过跟踪TCPConn的Write方法，了解了发送数据的过程以及fd的</description></item><item><title>go源码解析之TCP连接（四）——Write</title><link>https://erberry.github.io/post/go-tcp4/</link><pubDate>Sat, 12 Feb 2022 20:00:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp4/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 网络数据发送 上一章我们通过跟踪TCPConn的Read方法，了解了读取数据的过程，本章将</description></item><item><title>go源码解析之TCP连接（三）——Read</title><link>https://erberry.github.io/post/go-tcp3/</link><pubDate>Sat, 12 Feb 2022 19:59:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp3/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 网络数据接收 上一章我们通过跟踪TCPListener的Accept方法，了解了serve</description></item><item><title>go源码解析之TCP连接（二）——Accept</title><link>https://erberry.github.io/post/go-tcp2/</link><pubDate>Sat, 12 Feb 2022 19:58:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp2/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 连接是如何建立的 上一章我们通过跟踪net.Listen的调用，了解了socket的创建、</description></item><item><title>go源码解析之TCP连接（一）——Listen</title><link>https://erberry.github.io/post/go-tcp1/</link><pubDate>Sat, 12 Feb 2022 19:57:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp1/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 端口是如何监听的 首先奉上net文档中第一个映入眼帘的example 1 2 3 4 5 6 7 8 9 10 11</description></item></channel></rss>