<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码解析 on 刘玮的博客</title><link>https://erberry.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><description>Recent content in 源码解析 on 刘玮的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 12 Feb 2022 20:06:05 +0800</lastBuildDate><atom:link href="https://erberry.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>sync.Pool源码解析</title><link>https://erberry.github.io/post/go-sync-pool/</link><pubDate>Sat, 12 Feb 2022 20:06:05 +0800</pubDate><guid>https://erberry.github.io/post/go-sync-pool/</guid><description>简介 sync.Pool是go官方提供的多线程安全的对象缓存池。目的是达到内存复用，减少内存分配及gc带来的消耗。 官方fmt包就使用了sync</description></item><item><title>Go语言内置的goroutine池</title><link>https://erberry.github.io/post/goroutine-pool/</link><pubDate>Sat, 12 Feb 2022 20:05:05 +0800</pubDate><guid>https://erberry.github.io/post/goroutine-pool/</guid><description>相信每个用go写的项目都会搞一个go的协程池包，不论是自己写的还是借鉴开源代码。和其他语言编程中经常提到的线程池一样，协程池同样是通过协程复</description></item><item><title>go源码解析之TCP连接（七）——IO多路复用之事件通知</title><link>https://erberry.github.io/post/go-tcp7/</link><pubDate>Sat, 12 Feb 2022 20:03:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp7/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 TCP连接中的IO多路复用 上一章已经介绍了将socket注册到epoll中的过程，本章将</description></item><item><title>go源码解析之TCP连接（六）——IO多路复用之事件注册</title><link>https://erberry.github.io/post/go-tcp6/</link><pubDate>Sat, 12 Feb 2022 20:02:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp6/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 TCP连接中的IO多路复用 本章将介绍golang在tcp连接中的IO多路复用的实现 1. 背景</description></item><item><title>go源码解析之TCP连接（五）——Close</title><link>https://erberry.github.io/post/go-tcp5/</link><pubDate>Sat, 12 Feb 2022 20:01:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp5/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 连接关闭 上一章我们通过跟踪TCPConn的Write方法，了解了发送数据的过程以及fd的</description></item><item><title>go源码解析之TCP连接（四）——Write</title><link>https://erberry.github.io/post/go-tcp4/</link><pubDate>Sat, 12 Feb 2022 20:00:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp4/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 网络数据发送 上一章我们通过跟踪TCPConn的Read方法，了解了读取数据的过程，本章将</description></item><item><title>go源码解析之TCP连接（三）——Read</title><link>https://erberry.github.io/post/go-tcp3/</link><pubDate>Sat, 12 Feb 2022 19:59:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp3/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 网络数据接收 上一章我们通过跟踪TCPListener的Accept方法，了解了serve</description></item><item><title>go源码解析之TCP连接（二）——Accept</title><link>https://erberry.github.io/post/go-tcp2/</link><pubDate>Sat, 12 Feb 2022 19:58:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp2/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 连接是如何建立的 上一章我们通过跟踪net.Listen的调用，了解了socket的创建、</description></item><item><title>go源码解析之TCP连接（一）——Listen</title><link>https://erberry.github.io/post/go-tcp1/</link><pubDate>Sat, 12 Feb 2022 19:57:05 +0800</pubDate><guid>https://erberry.github.io/post/go-tcp1/</guid><description>go源码解析之TCP连接系列基于go源码1.16.5 端口是如何监听的 首先奉上net文档中第一个映入眼帘的example 1 2 3 4 5 6 7 8 9 10 11</description></item></channel></rss>